
[TOC]

# 前言
官方文档: https://docs.oracle.com/javase/specs/index.html
本文摘要自Java虚拟机规范，方便自己查阅。

# Java虚拟机结构
## 数据类型
与 Java 程序语言中的数据类型相似，Java 虚拟机可以操作的数据类型可分为两类:原始类 型(Primitive Types，也经常翻译为原生类型或者基本类型)和引用类型(Reference Types)。 与之对应，也存在有原始值(Primitive Values)和引用值(Reference Values)两种类 型的数值可用于变量赋值、参数传递、方法返回和运算操作。
Java 虚拟机希望尽可能多的类型检查能在程序运行之前完成，换句话说，编译器应当在编译 期间尽最大努力完成可能的类型检查，使得虚拟机在运行期间无需进行这些操作。原始类型的值不 需要通过特殊标记或别的额外识别手段来在运行期确定它们的实际数据类型，也无需刻意将它们与 引用类型的值区分开来，虚拟机的字节码指令本身就可以确定它的指令操作数的类型是什么，所以 可以利用这种特性即可直接确定操作数的数值类型。举个例子，iadd、ladd、fadd 和 dadd 这 几条指令的操作含义都是将两个数值相加，并返个相加的结果，但是每一条指令都有自己的专属操 作数类型，此处按顺序分别为:int、long、float 和 double。关于虚拟机字节码指令的介绍， 读者可以参见本章的“§2.11 指令集简介”部分。
Java 虚拟机是直接支持对象的，这里的对象可以是指动态分配的某个类的实例，也可以指某 个数组的实例。虚拟机中使用 reference 类型1来表示对某个对象的引用，reference 类型的 值读者可以想象成类似于一个指向对象的指针。每一个对象都可能存在多个指向它的引用，对象的 操作、传递和检查都通过引用它的 reference 类型的数据进行操作。

## 原始类型与值
Java 虚拟机所支持的原始数据类型包括了数值类型(Numeric Types)、布尔类型(Boolean Type §2.3.4)和 returnAddress 类型(§2.3.3)三类。其中数值类型又分为整型类型 (Integral Types，§2.3.1)和浮点类型(Floating-Point Types，§2.3.2)两种， 其中:

整数类型包括:
- byte 类型:值为 8 位有符号二进制补码整数，默认值为零。
- short 类型:值为 16 位有符号二进制补码整数，默认值为零。
- int 类型:值为 32 位有符号二进制补码整数，默认值为零。
- long 类型:值为 64 位有符号二进制补码整数，默认值为零。
- char 类型:值为使用 16 位无符号整数表示的、指向基本多文本平面(Basic
Multilingual Plane，BMP1)的 Unicode 值，以 UTF-16 编码，默认值为 Unicode
的 null 值('\u0000')。
浮点类型包括:
- float 类型:值为单精度浮点数集合2中的元素，或者(如果虚拟机支持的话)是单精度 扩展指数(Float-Extended-Exponent)集合中的元素。默认值为正数零。
- double 类型:取值范围是双精度浮点数集合中的元素，或者(如果虚拟机支持的话)是 双精度扩展指数(Double-Extended-Exponent)集合中的元素。默认值为正数零。
布尔类型:
- boolean 类型:取值范围为布尔值 true 和 false，默认值为 false。
returnAddress 类型:

returnAddress 类型:表示一条字节码指令的操作码(Opcode)。在所有的虚拟机支
持的原始类型之中，只有 returnAddress 类型是不能直接 Java 语言的数据类型对应 起来的。

### 整型类型与整型值
Java 虚拟机中的整型类型的取值范围如下:
- 对于 byte 类型，取值范围是从-128 至 127(-27 至 27-1)，包括-128 和 127。
- 对于 short 类型，取值范围是从−32768 至 32767(-215 至 215-1)，包括−32768 和
32767。
对于 int 类型，取值范围是从−2147483648 至 2147483647(-231 至 231-1)，包括− 2147483648 和 2147483647。
- 对于 long 类型，取值范围是从−9223372036854775808 至 9223372036854775807 (-263 至 263-1)，包括−9223372036854775808 和 9223372036854775807。
- 对于 char 类型，取值范围是从 0 至 65535，包括 0 和 65535。

### 浮点类型、取值集合及浮点值
浮点类型包含float类型和double类型两种，它们在概念上与《IEEE Standard for Binary Floating-Point Arithmetic》ANSI/IEEE Std. 754-1985(IEEE, New York) 标准中定义的32位单精度和64位双精度IEEE 754格式取值和操作都是一致的。（浮点数我也没搞懂）

### returnAddress 类型和值
returnAddress 类型会被 Java 虚拟机的 jsr、ret 和 jsr_w 指令1所使用。（这几条指令以前主要被使用来实现 finally 语句块，后来改为冗余 finally 块代码的方式来实 现，甚至到了 JDK7 时，虚拟机已不允许 Class 文件内出现这几条指令。那相应地，returnAddress 类型就处 于名存实亡的状态） returnAddress 类型的值指向一条虚拟机指令的操作码。与前面介绍的那些数值类的原始类型 不同，returnAddress 类型在 Java 语言之中并不存在相应的类型，也无法在程序运行期间更改 returnAddress 类型的值。

### boolean类型
虽然 Java 虚拟机定义了 boolean 这种数据类型，但是只对它提供了非常有限的支持。在 Java 虚拟机中没有任何供 boolean 值专用的字节码指令，在 Java 语言之中涉及到 boolean 类型值的运算，在编译之后都使用 Java 虚拟机中的 int 数据类型来代替。
Java 虚拟机直接支持 boolean 类型的数组，虚拟机的 newarray 指令可以创建这种数组。
boolean 的数组类型的访问与修改共用 byte 类型数组的 baload 和 bastore 指令1。（在 Oracle 公司的虚拟机实现里，Java 语言里面的 boolean 数组将会被编码成 Java 虚拟机的 byte 数 组，每个 boolean 元素占 8 位长度。）

### 引用类型与值
Java虚拟机中有三种引用类型:类类型(Class Types)、数组类型(Array Types)和 接口类型(Interface Types)。这些引用类型的值分别由类实例、数组实例和实现了某个接口 的类实例或数组实例动态创建。
其中，数组类型还包含一个单一维度(即长度不由其类型决定)的组件类型(Component Type)，一个数组的组件类型也可以是数组。但从任意一个数组开始，如果发现其组件类型也是数 组类型的话，继续重复取这个数组的组件类型，这样操作不断执行，最终一定可以遇到组件类型不 是数组的情况，这时就把这种类型成为数组类型的元素类型(Element Type)。数组的元素类型 必须是原始类型、类类型或者接口类型之中的一种。
在引用类型的值中还有一个特殊的值:null，当一个引用不指向任何对象的时候，它的值就 用 null 来表示。一个为 null 的引用，在没有上下文的情况下不具备任何实际的类型，但是有具 体上下文时它可转型为任意的引用类型。引用类型的默认值就是 null。
Java 虚拟机规范并没有规定 null 在虚拟机实现中应当怎样编码表示。

## 运行时数据区
Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机 启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区 域会随着线程开始和结束而创建和销毁。

### PC 寄存器
Java 虚拟机可以支持多条线程同时执行(可参考《Java 语言规范》第 17 章)，每一条 Java 虚拟机线程都有自己的PC(Program Counter)寄存器。在任意时刻，一条Java虚拟机线程 只会执行一个方法的代码，这个正在被线程执行的方法称为该线程的当前方法(Current Method，§2.6)。如果这个方法不是 native 的，那 PC 寄存器就保存 Java 虚拟机正在执行的 字节码指令的地址，如果该方法是 native 的，那 PC 寄存器的值是 undefined。PC 寄存器的容 量至少应当能保存一个 returnAddress 类型的数据或者一个与平台相关的本地指针的值。

### Java 虚拟机栈
每一条 Java 虚拟机线程都有自己私有的 Java 虚拟机栈(Java Virtual Machine Stack) 1，这个栈与线程同时创建，用于存储栈帧(Frames, §2.6)。Java 虚拟机栈的作用与传统语 言(例如 C 语言)中的栈非常类似，就是用于存储局部变量与一些过程结果的地方。另外，它在 方法调用和返回中也扮演了很重要的角色。因为除了栈帧的出栈和入栈之外，Java 虚拟机栈不会 再受其他因素的影响，所以栈帧可以在堆中分配2，Java 虚拟机栈所使用的内存不需要保证是连 续的。
Java 虚拟机规范允许 Java 虚拟机栈被实现成固定大小的或者是根据计算动态扩展和收缩 的。如果采用固定大小的 Java 虚拟机栈设计，那每一条线程的 Java 虚拟机栈容量应当在线程创 建的时候独立地选定。Java 虚拟机实现应当提供给程序员或者最终用户调节虚拟机栈初始容量的 手段，对于可以动态扩展和收缩 Java 虚拟机栈来说，则应当提供调节其最大、最小容量的手段。

Java 虚拟机栈可能发生如下异常情况:
- 如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量时，Java 虚拟机将会抛出一
个 StackOverflowError 异常
- 如果 Java 虚拟机栈可以动态扩展，并且扩展的动作已经尝试过，但是目前无法申请到足够的内存去完成扩展，或者在建立新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚
拟机将会抛出一个 OutOfMemoryError 异常。

### Java 堆
在 Java 虚拟机中，堆(Heap)是可供各条线程共享的运行时内存区域，也是供所有类实例 和数组对象分配内存的区域。
Java 堆在虚拟机启动的时候就被创建，它存储了被自动内存管理系统(Automatic Storage Management System，也即是常说的“Garbage Collector(垃圾收集器)”)所管理的各种 对象，这些受管理的对象无需，也无法显式地被销毁。本规范中所描述的 Java 虚拟机并未假设采 用什么具体的技术去实现自动内存管理系统。虚拟机实现者可以根据系统的实际需要来选择自动内 存管理技术。Java 堆的容量可以是固定大小的，也可以随着程序执行的需求动态扩展，并在不需 要过多空间时自动收缩。Java 堆所使用的内存不需要保证是连续的。
Java 虚拟机实现应当提供给程序员或者最终用户调节 Java 堆初始容量的手段，对于可以动 态扩展和收缩 Java 堆来说，则应当提供调节其最大、最小容量的手段。

Java 堆可能发生如下异常情况:如果实际所需的堆超过了自动内存管理系统能提供的最大容量，那Java虚拟机将会抛出一个
OutOfMemoryError 异常。

### 方法区
在Java虚拟机中，方法区(Method Area)是可供各条线程共享的运行时内存区域。方法 区与传统语言中的编译代码储存区(Storage Area Of Compiled Code)或者操作系统进程 的正文段(Text Segment)的作用非常类似，它存储了每一个类的结构信息，例如运行时常量 池(Runtime Constant Pool)、字段和方法数据、构造函数和普通方法的字节码内容、还包 括一些在类、实例、接口初始化时用到的特殊方法(§2.9)。
方法区在虚拟机启动的时候被创建，虽然方法区是堆的逻辑组成部分，但是简单的虚拟机实现 可以选择在这个区域不实现垃圾收集。这个版本的 Java 虚拟机规范也不限定实现方法区的内存位置和编译代码的管理策略。方法区的容量可以是固定大小的，也可以随着程序执行的需求动态扩展， 并在不需要过多空间时自动收缩。方法区在实际内存空间中可以是不连续的。
Java 虚拟机实现应当提供给程序员或者最终用户调节方法区初始容量的手段，对于可以动态 扩展和收缩方法区来说，则应当提供调节其最大、最小容量的手段。
方法区可能发生如下异常情况: 如果方法区的内存空间不能满足内存分配请求，那Java虚拟机将抛出一个
OutOfMemoryError 异常。

### 运行时常量池
运行时常量池(Runtime Constant Pool)是每一个类或接口的常量池(Constant_Pool， §4.4)的运行时表示形式，它包括了若干种不同的常量:从编译期可知的数值字面量到必须运行 期解析后才能获得的方法或字段引用。运行时常量池扮演了类似传统语言中符号表(Symbol Table)的角色，不过它存储数据范围比通常意义上的符号表要更为广泛。
每一个运行时常量池都分配在 Java 虚拟机的方法区之中(§2.5.4)，在类和接口被加载到 虚拟机后，对应的运行时常量池就被创建出来。
在创建类和接口的运行时常量池时，可能会发生如下异常情况: 当创建类或接口的时候，如果构造运行时常量池所需要的内存空间超过了方法区所能提供的最
大值，那 Java 虚拟机将会抛出一个 OutOfMemoryError 异常。

### 本地方法栈
Java虚拟机实现可能会使用到传统的栈(通常称之为“C Stacks”)来支持native方法 (指使用 Java 以外的其他语言编写的方法)的执行，这个栈就是本地方法栈(Native Method Stack)。当 Java 虚拟机使用其他语言(例如 C 语言)来实现指令集解释器时，也会使用到本地 方法栈。如果 Java 虚拟机不支持 natvie 方法，并且自己也不依赖传统栈的话，可以无需支持本 地方法栈，如果支持本地方法栈，那这个栈一般会在线程创建的时候按线程分配。
Java 虚拟机规范允许本地方法栈被实现成固定大小的或者是根据计算动态扩展和收缩的。如 果采用固定大小的本地方法栈，那每一条线程的本地方法栈容量应当在栈创建的时候独立地选定。 一般情况下，Java 虚拟机实现应当提供给程序员或者最终用户调节虚拟机栈初始容量的手段，对 于长度可动态变化的本地方法栈来说，则应当提供调节其最大、最小容量的手段。

### 栈帧
栈帧(Frame)是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接 (Dynamic Linking)、方法返回值和异常分派(Dispatch Exception)。
栈帧随着方法调用而创建，随着方法结束而销毁——无论方法是正常完成还是异常完成(抛出 了在方法内未被捕获的异常)都算作方法结束。栈帧的存储空间分配在 Java 虚拟机栈(§2.5.5) 之中，每一个栈帧都有自己的局部变量表(Local Variables，§2.6.1)、操作数栈(Operand Stack，§2.6.2)和指向当前方法所属的类的运行时常量池(§2.5.5)的引用。
局部变量表和操作数栈的容量是在编译期确定，并通过方法的 Code 属性(§4.7.3)保存及 提供给栈帧使用。因此，栈帧容量的大小仅仅取决于 Java 虚拟机的实现和方法调用时可被分配的 内存。
在一条线程之中，只有目前正在执行的那个方法的栈帧是活动的。这个栈帧就被称为是当前栈 帧(Current Frame)，这个栈帧对应的方法就被称为是当前方法(Current Method)，定义 这个方法的类就称作当前类(Current Class)。对局部变量表和操作数栈的各种操作，通常都 指的是对当前栈帧的对局部变量表和操作数栈进行的操作。
如果当前方法调用了其他方法，或者当前方法执行结束，那这个方法的栈帧就不再是当前栈帧
了。当一个新的方法被调用，一个新的栈帧也会随之而创建，并且随着程序控制权移交到新的方法
而成为新的当前栈帧。当方法返回的之际，当前栈帧会传回此方法的执行结果给前一个栈帧，在方法返回之后，当前栈帧就随之被丢弃，前一个栈帧就重新成为当前栈帧了。 请读者特别注意，栈帧是线程本地私有的数据，不可能在一个栈帧之中引用另外一条线程的栈帧。

#### 局部变量表
每个栈帧(§2.6)内部都包含一组称为局部变量表(Local Variables)的变量列表。栈 帧中局部变量表的长度由编译期决定，并且存储于类和接口的二进制表示之中，既通过方法的 Code 属性(§4.7.3)保存及提供给栈帧使用。
一个局部变量可以保存一个类型为 boolean、byte、char、short、float、reference 和 returnAddress 的数据，两个局部变量可以保存一个类型为 long 和 double 的数据。
局部变量使用索引来进行定位访问，第一个局部变量的索引值为零，局部变量的索引值是从零 至小于局部变量表最大容量的所有整数。
long 和 double 类型的数据占用两个连续的局部变量，这两种类型的数据值采用两个局部变 量之中较小的索引值来定位。例如我们讲一个 double 类型的值存储在索引值为 n 的局部变量中， 实际上的意思是索引值为 n 和 n+1 的两个局部变量都用来存储这个值。索引值为 n+1 的局部变量 是无法直接读取的，但是可能会被写入，不过如果进行了这种操作，就将会导致局部变量 n 的内 容失效掉。
上文中提及的局部变量 n 的 n 值并不要求一定是偶数，Java 虚拟机也不要求 double 和 long 类型数据采用 64 位对其的方式存放在连续的局部变量中。虚拟机实现者可以自由地选择适当的方 式，通过两个局部变量来存储一个 double 或 long 类型的值。
Java 虚拟机使用局部变量表来完成方法调用时的参数传递，当一个方法被调用的时候，它的 参数将会传递至从 0 开始的连续的局部变量表位置上。特别地，当一个实例方法被调用的时候， 第 0 个局部变量一定是用来存储被调用的实例方法所在的对象的引用(即 Java 语言中的“this” 关键字)。后续的其他参数将会传递至从 1 开始的连续的局部变量表位置上。

#### 操作数栈
每一个栈帧(§2.6)内部都包含一个称为操作数栈(Operand Stack)的后进先出 (Last-In-First-Out，LIFO)栈。栈帧中操作数栈的长度由编译期决定，并且存储于类和接 口的二进制表示之中，既通过方法的 Code 属性(§4.7.3)保存及提供给栈帧使用。
在上下文明确，不会产生误解的前提下，我们经常把“当前栈帧的操作数栈”直接简称为“操 作数栈”。
操作数栈所属的栈帧在刚刚被创建的时候，操作数栈是空的。Java 虚拟机提供一些字节码指 令来从局部变量表或者对象实例的字段中复制常量或变量值到操作数栈中，也提供了一些指令用于 从操作数栈取走数据、操作数据和把操作结果重新入栈。在方法调用的时候，操作数栈也用来准备 调用方法的参数以及接收方法返回结果。
举个例子，iadd 字节码指令的作用是将两个 int 类型的数值相加，它要求在执行的之前操作 数栈的栈顶已经存在两个由前面其他指令放入的 int 型数值。在 iadd 指令执行时，2 个 int 值 从操作栈中出栈，相加求和，然后将求和结果重新入栈。在操作数栈中，一项运算常由多个子运算 (Subcomputations)嵌套进行，一个子运算过程的结果可以被其他外围运算所使用。
每一个操作数栈的成员(Entry)可以保存一个 Java 虚拟机中定义的任意数据类型的值，包 括 long 和 double 类型。
在操作数栈中的数据必须被正确地操作，这里正确操作是指对操作数栈的操作必须与操作数栈 栈顶的数据类型相匹配，例如不可以入栈两个 int 类型的数据，然后当作 long 类型去操作他们， 或者入栈两个 float 类型的数据，然后使用 iadd 指令去对它们进行求和。有一小部分 Java 虚 拟机指令(例如 dup 和 swap 指令)可以不关注操作数的具体数据类型，把所有在运行时数据区 中的数据当作裸类型(Raw Type)数据来操作，这些指令不可以用来修改数据，也不可以拆散那 些原本不可拆分的数据，这些操作的正确性将会通过 Class 文件的校验过程(§4.10)来强制保 障。
在任意时刻，操作数栈都会有一个确定的栈深度，一个 long 或者 double 类型的数据会占用 两个单位的栈深度，其他数据类型则会占用一个单位深度。

#### 动态链接
每一个栈帧(§2.6)内部都包含一个指向运行时常量池(§2.5.5)的引用来支持当前方法 的代码实现动态链接(Dynamic Linking)。在 Class 文件里面，描述一个方法调用了其他方法， 或者访问其成员变量是通过符号引用(Symbolic Reference)来表示的，动态链接的作用就是 将这些符号引用所表示的方法转换为实际方法的直接引用。类加载的过程中将要解析掉尚未被解析 的符号引用，并且将变量访问转化为访问这些变量的存储结构所在的运行时内存位置的正确偏移 量。
由于动态链接的存在，通过晚期绑定(Late Binding)使用的其他类的方法和变量在发生 变化时，将不会对调用它们的方法构成影响。

#### 方法正常调用完成
方法正常调用完成是指在方法的执行过程中，没有任何异常(§2.10)被抛出——包括直接 从 Java 虚拟机之中抛出的异常以及在执行时通过 throw 语句显式抛出的异常。如果当前方法调 用正常完成的话，它很可能会返回一个值给调用它的方法，方法正常完成发生在一个方法执行过程 中遇到了方法返回的字节码指令(§2.11.8)的时候，使用哪种返回指令取决于方法返回值的数 据类型(如果有返回值的话)。
在这种场景下，当前栈帧(§2.6)承担着回复调用者状态的责任，其状态包括调用者的局部 变量表、操作数栈和被正确增加过来表示执行了该方法调用指令的程序计数器等。使得调用者的代 码能在被调用的方法返回并且返回值被推入调用者栈帧的操作数栈后继续正常地执行。

#### 方法异常调用完成
方法异常调用完成是指在方法的执行过程中，某些指令导致了 Java 虚拟机抛出异常 (§2.10)，并且虚拟机抛出的异常在该方法中没有办法处理，或者在执行过程中遇到了 athrow 字节码指令显式地抛出异常，并且在该方法内部没有把异常捕获住。如果方法异常调用完成，那一 定不会有方法返回值返回给它的调用者。

## 对象的表示
Java 虚拟机规范不强制规定对象的内部结构应当如何表示（class实例，对象堆中实例数据）

## 初始化方法的特殊命名
在 Java 虚拟机层面上，Java 语言中的构造函数在《Java 语言规范 (第三版)》(下文简称 JLS3，§8.8)是以一个名为<init>的特殊实例初始化方法的形式出现的，<init>这个方法名 称是由编译器命名的，因为它并非一个合法的 Java 方法名字，不可能通过程序编码的方式实现。 实例初始化方法只能在实例的初始化期间，通过 Java 虚拟机的 invokespecial 指令来调用， 只有在实例正在构造的时候，实例初始化方法才可以被调用访问(JLS3，§6.6)。
一个类或者接口最多可以包含不超过一个类或接口的初始化方法，类或者接口就是通过这个方 法完成初始化的(§5.5)。这个方法是一个不包含参数的静态方法，名为<clinit>（静态代码库被编译到类初始化方法中）。这个名字 也是由编译器命名的，因为它并非一个合法的 Java 方法名字，不可能通过程序编码的方式实现。 类或接口的初始化方法由 Java 虚拟机自身隐式调用，没有任何虚拟机字节码指令可以调用这个方 法，只有在类的初始化阶段中会被虚拟机自身调用。

## 异常
Java 虚拟机里面的异常使用 Throwable 或其子类的实例来表示，抛异常的本质实际上是程 序控制权的一种即时的、非局部(Nonlocal)的转换——从异常抛出的地方转换至处理异常的地 方。
绝大多数的异常的产生都是由于当前线程执行的某个操作所导致的，这种可以称为是同步的异 常。与之相对的，异步异常是指在程序的其他任意地方进行的动作而导致的异常。Java 虚拟机中 异常的出现总是由下面三种原因之一导致的:
1. 虚拟机同步检测到程序发生了非正常的执行情况，这时异常将会紧接着在发生非正常执行 情况的字节码指令之后抛出。例如: 字节码指令所蕴含的操作违反了 Java 语言的语义，如访问一个超出数组边界范围的 元素。类在加载或者链接时出现错误。使用某些资源的时候产生资源限制，例如使用了太多的内存。
2. athrow 字节码指令被执行
3. 由于以下原因，导致了异步异常的出现:
  调用了 Thread 或者 ThreadGroup 的 stop 方法。Java 虚拟机实现的内部程序错误。
  当某条线程调用了 stop 方法时，将会影响到其他的线程，或者在线程组中的所有线程。 这时候其他线程中出现的异常就是异步异常，因为这些异常可能出现在程序执行过程的任 何位置。虚拟机的内部异常也被认为是一种异步异常(§6.3)
  《Java 虚拟机规范》允许在异步异常被抛出时额外执行一小段有限的代码，允许代码优化器 在不违反 Java 语言语义的前提下检测并把这些异常在可处理它们的地方抛出
  抛出异常的动作在 Java 虚拟机之中是一种被精确定义的程序控制权转移过程，当异常抛出、 程序控制权发生转移的那一刻，所有在异常抛出的位置之前的字节码指令所产生的影响（这里的“影响”包括了异常出现之前的字节码指令执行后对局部变量表、操作数栈、其他运行时数 据区域以及虚拟机外部资源产生的影响。）都应当是 可以被观察到的，而在异常抛出的位置之后的字节码指令，则应当是没有被执行过的。如果虚拟机 执行的代码是被优化后的代码（这里的“优化后的代码”主要是指进行了指令重排序优化的代码），有一些在异常出现位置之后的代码可能已经被执行了，那这些优 化过的代码必须保证被它们提前执行所产生的影响对用户程序来说都是不可见的。
  由 Java 虚拟机执行的每一个方法都会配有零至多个异常处理器(Exception Handlers)， 异常处理器描述了其在方法代码中的有效作用范围(通过字节码偏移量范围来描述)、能处理的异 常类型以及处理异常的代码所在的位置。要判断某个异常处理器是否可以处理某个具体的异常，需 要同时检查异常出现的位置是否在异常处理的有效作用范围内并且出现的异常是否异常处理器声明可以处理的异常类型或其子类型两个条件。当有异常被抛出时，Java 虚拟机搜索当前方法的包 含的各个异常处理器，如果能找到可以处理该异常的异常处理器，则将代码控制权转向到异常处理 器中描述的处理异常的分支之中。
  搜索异常处理器时的搜索顺序是很关键的，在 Class 文件里面，每个方法的异常处理器都存 储在一个表中(§4.7.3)。在运行时，当有异常出现之后，Java 虚拟机就按照 Class 文件中的 异常处理器表描述异常处理器的先后顺序，从前至后进行搜索。
  需要注意，Java 虚拟机本身不会对方法的对异常处理器表做排序或者其他方式的强制处理， 所以 Java 语言中对异常处理的语义，实际上是通过编译器适当安排异常处理器在表中的顺序来协 助完成的。在 Class 文件中定义了明确的异常处理器查找顺序，才能保证无论 Class 文件是通过 何种途径产生的，Java 虚拟机执行时都能有一致的行为表现。

## 字节码指令集简介 

Java 虚拟机的指令由一个字节长度的、代表着某种特定操作含义的操作码(Opcode)以及 跟随其后的零至多个代表此操作所需参数的操作数(Operands)所构成。虚拟机中许多指令并不 包含操作数，只有一个操作码。 

如果忽略异常处理，那 Java 虚拟机的解释器使用下面这个伪代码的循环即可有效地工作: 

```java

do {
自动计算 PC 寄存器以及从 PC 寄存器的位置取出操作码; if (存在操作数) 取出操作数; 执行操作码所定义的操作
} while (处理下一次循环);
```

操作数的数量以及长度取决于操作码，如果一个操作数的长度超过了一个字节，那它将会以 Big-Endian 顺序存储——即高位在前的字节序。举个例子，如果要将一个 16 位长度的无符号整 数使用两个无符号字节存储起来(将它们命名为 byte1 和 byte2)，那它们的值应该是这样的: 

```
   (byte1 << 8) | byte2
```

字节码指令流应当都是单字节对齐的，只有“tableswitch”和“lookupswitch”两条指 令例外，由于它们的操作数比较特殊，都是以 4 字节为界划分开的，所以这两条指令那个也需要 预留出相应的空位来实现对齐。 

限制 Java 虚拟机操作码的长度为一个字节，并且放弃了编译后代码的参数长度对齐，是为了 尽可能地获得短小精干的编译代码，即使这可能会让 Java 虚拟机的具体实现付出一定的性能成本 为代价。由于每个操作码只能有一个字节长度，所以直接限制了整个指令集的数量(字节码无法超过 256 条的限制就来源于此  )，又由于没有 假设数据是对齐好的，这就意味着虚拟机处理那些超过一个字节的数据的时候，不得不在运行时从 字节中重建出具体数据的结构，这在某种程度上会损失一些性能。 

### 方法调用和返回指令
以下四条指令用于方法调用:
invokevirtual 指令用于调用对象的实例方法，根据对象的实际类型进行分派(虚方法分 派)，这也是 Java 语言中最常见的方法分派方式。
invokeinterface 指令用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的 对象，找出适合的方法进行调用。
invokespecial 指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法(§ 2.9)、私有方法和父类方法。
invokestatic 指令用于调用类方法(static 方法)。
而方法返回指令则是根据返回值的类型区分的，包括有 ireturn(当返回值是 boolean、 byte、char、short 和 int 类型时使用)、lreturn、freturn、dreturn 和 areturn，另 外还有一条 return 指令供声明为 void 的方法、实例初始化方法、类和接口的类初始化方法使用。
在程序中显式抛出异常的操作会由 athrow 指令实现，除了这种情况，还有别的异常会在其
他 Java 虚拟机指令检测到异常状况时由虚拟机自动抛出。

### 同步
Java 虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程(Monitor)来支持的。 方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作(§
2.11.8)之中。虚拟机可以从方法常量池中的方法表结构(method_info Structure，§4.6) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有管程， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放管程。在方法执行期 间，执行线程持有了管程，其他任何线程都无法再获得同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的管程将在异常抛到同步方法 之外时自动释放。
同步一段指令集序列通常是由 Java 语言中的 synchronized 块来表示的，Java 虚拟机的 指令集中有 monitorenter 和 monitorexit 两条指令来支持 synchronized 关键字的语义， 正确实现 synchronized 关键字需要编译器与 Java 虚拟机两者协作支持(读者可参见§3.14 中关于同步的描述)。
结构化锁定(Structured Locking)是指在方法调用期间每一个管程退出都与前面的管程 进入相匹配的情形。因为无法保证所有提交给 Java 虚拟机执行的代码都满足结构化锁定，所以 Java 虚拟机允许(但不强制要求)通过以下两条规则来保证结构化锁定成立。假设 T 代表一条线 程，M 代表一个管程的话:
1. T 在方法执行时持有管程 M 的次数必须与 T 在方法完成(包括正常和非正常完成)时释 放管程 M 的次数相等。
2. 找方法调用过程中，任何时刻都不会出现线程 T 释放管程 M 的次数比 T 持有管程 M 次数 多的情况。
  请注意，在同步方法调用时自动持有和释放管程的过程也被认为是在方法调用期间发生。
  
### 类库
Java 虚拟机必须对不同平台下 Java 类库的实现提供充分的支持，因为其中有一些类库如果 没有 Java 虚拟机的支持的话是根本无法实现的。
可能需要 Java 虚拟机特殊支持的类库包括有:
- 反射，譬如在 java.lang.reflect 包中的各个类和 java.lang.Class 类
- 类和接口的加载和创建，最显而易见的例子就是 java.lang.ClassLoader 类
- 类和接口的链接和初始化，上一点的例子也适用于这点
- 安全，譬如在 java.security 包中的各个类和 java.lang.SecurityManager 等其他类
- 多线程，譬如 java.lang.Thread 类
- 弱引用，譬如在 java.lang.ref 包中的各个类



# 为JAVA虚拟机编译

Java 虚拟机是为了支持 Java 语言而的设计的。Oracle 的 JDK 包括两部分内容:一部分是 将 Java 源代码编译成 Java 虚拟机的指令集的编译器，另一部分是用于 Java 虚拟机的运行时环 境。理解编译器是如何与 Java 虚拟机协同工作的，对编译器开发人员来说很有好处，同样也有助 于理解 Java 虚拟机本身。
请注意:术语“编译器”在某些上下文场景中专指把 Java 虚拟机的指令集转换为特定 CPU 指令集的翻译器。譬如即时代码生成器(Just-In-Time/JIT Code Generator)就是一种在 Class 文件中的代码被 Java 虚拟机代码加载后，生成与平台相关的特定指令的编译器。但是在 本章中讨论的编译器将不考虑这类代码生成的问题，只会涉及到从使用 Java 语言编写的源代码编 译为 Java 虚拟机指令集的编译器。

## 各种编译指令



# Class文件结构

每一个 Class 文件都对应着唯一一个类 或接口的定义信息，但是相对地，类或接口并不一定都得定义在文件里(譬如类或接口也可以通过 类加载器直接生成)。本章中，我们只是通俗地将任意一个有效的类或接口所应当满足的格式称为 “Class 文件格式”，即使它不一定以磁盘文件的形式存在。 

每个 Class 文件都是由 8 字节为单位的字节流组成，所有的 16 位、32 位和 64 位长度的数 据将被构造成 2 个、4 个和 8 个 8 字节单位来表示。多字节数据项总是按照 Big-Endian(Big-Endian 顺序是指按高位字节在地址最低位，最低字节在地址最高位来存储数据，它是 SPARC、 PowerPC 等处理器的默认多字节存储顺序，而 x86 等处理器则是使用了相反的 Little-Endian 顺序来存储数据。 为了保证 Class 文件在不同硬件上具备同样的含义，因此在 Java 虚拟机规范中是有必要严格规定了数据存储顺 序的。)的顺 序进行存储。在Java SDK中，访问这种格式的数据可以使用java.io.DataInput、 java.io.DataOutput 等接口和 java.io.DataInputStream 和 java.io.DataOutputStream 等类来实现。 

本章还定义了一组私有数据类型来表示 Class 文件的内容，它们包括 u1，u2 和 u4，分别代 表了1、2和4个字节的无符号数。在Java SDK中这些类型的数据可以通过实现接口 java.io.DataInput 中的 readUnsignedByte、readUnsignedShort 和 readInt 方法进 行读取。 

本章将采用类似 C 语言结构体的伪结构来描述 Class 文件格式。为了避免与类的字段、类的 实例等概念产生混淆，在此把用于描述类结构格式的内容定义为项(Item)。在 Class 文件中， 各项按照严格顺序连续存放的，它们之间没有任何填充或对齐作为各项间的分隔符号。 

表(Table)是由任意数量的可变长度的项组成，用于表示 Class 文件内容的一系列复合结 构。尽管我们采用类似 C 语言的数组语法来表示表中的项，但是读者应当清楚意识到，表是由可 变长数据组成的复合结构(表中每项的长度不固定)，因此无法直接将字节偏移量来作为索引对表 进行访问。而我们描述一个数据结构为数组(Array)时，就意味着它含有零至多个长度固定的项 组成，这个时候则可以采用数组索引的方式来访问它。

## ClassFile 结构  

每一个 Class 文件对应于一个如下所示的 ClassFile 结构体。 

```c

ClassFile {
   u4 magic;
   u2 minor_version;
   u2 major_version;
   u2 constant_pool_count;
   cp_info constant_pool[constant_pool_count-1];
   u2 access_flags;
   u2 this_class;
   u2 super_class;
   u2 interfaces_count;
   u2 interfaces[interfaces_count];
   u2 fields_count;
   field_info fields[fields_count];
   u2 methods_count;
   method_info methods[methods_count];
   u2 attributes_count;
   attribute_info attributes[attributes_count];
} 
```

ClassFile 结构体中，各项的含义描述如下: 

- magic 

  魔数，魔数的唯一作用是确定这个文件是否为一个能被虚拟机所接受的 Class 文件。魔 

  数值固定为 0xCAFEBABE，不会改变。 

- minor_version、major_version 

  副版本号和主版本号，minor_version 和 major_version 的值分别表示 Class 文件 的副、主版本。它们共同构成了 Class 文件的格式版本号。譬如某个 Class 文件的主版 本号为 M，副版本号为 m，那么这个 Class 文件的格式版本号就确定为 M.m。Class 文 件格式版本号大小的顺序为:1.5 < 2.0 < 2.1。 
  一个 Java 虚拟机实例只能支持特定范围内的主版本号(Mi 至 Mj)和 0 至特定范围 内(0 至 m)的副版本号。假设一个 Class 文件的格式版本号为 V，仅当 Mi.0 ≤ v ≤ Mj.m 成立时，这个 Class 文件才可以被此 Java 虚拟机支持。不同版本的 Java 虚拟机实现 支持的版本号也不同，高版本号的 Java 虚拟机实现可以支持低版本号的 Class 文件。

- constant_pool_count

  常量池计数器，constant_pool_count 的值等于 constant_pool 表中的成员数加 1。 constant_pool 表的索引值只有在大于 0 且小于 constant_pool_count 时才会被 认为是有效的（虽然值为 0 的 constant_pool 索引是无效的，但其他用到常量池的数据结构可以使用索引 0 来 表示“不引用任何一个常量池项”的意思。 ），对于 long 和 double 类型有例外情况，可参见后文。

- constant_pool[]  

  常量池，constant_pool 是一种表结构(§4.4)，它包含 Class 文件结构及其子结构 中引用的所有字符串常量、类或接口名、字段名和其它常量。常量池中的每一项都具备相 同的格式特征——第一个字节作为类型标记用于识别该项是哪种类型的常量，称为“tag byte”。常量池的索引范围是 1 至 constant_pool_count−1。 

- access_flags  

  访问标志，access_flags 是一种掩码标志，用于表示某个类或者接口的访问权限及基 

  础属性。access_flags 的取值范围和相应含义见表 4.1 所示 

  表 4.1 访问和修饰符标志 

  | 标记名         | 值      | 含义                                                    |
  | -------------- | ------- | ------------------------------------------------------- |
  | ACC_PUBLIC     | 0x0001  | 可以被包的类外访问                                      |
  | ACC_FINAL      | 0x00010 | 不允许有子类                                            |
  | ACC_SUPER      | 0x0020  | 当用到 invokespecial 指令时，需要特殊处理3的 父类方法。 |
  | ACC_INTERFACE  | 0x0200  | 标识定义的是接口而不是类                                |
  | ACC_ABSTRACT   | 0x0400  | 不能被实例化                                            |
  | ACC_SYNTHETIC  | 0x1000  | 标识并非 Java 源码生成的代码                            |
  | ACC_ANNOTATION | 0x2000  | 标识注解类型                                            |
  | ACC_ENUM       | 0x4000  | 标识枚举类型                                            |

- this_class

- super_class

- interfaces_count

- interfaces[]

- 。。。



# 加载、链接与初始化

## 

  

  

  

  