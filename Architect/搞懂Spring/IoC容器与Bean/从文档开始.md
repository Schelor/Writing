# Spring IoC与Bean札记

<a name="3SZyI"></a>
# 容器概览
<a name="o5Hvp"></a>
## 配置元数据(装配方式)
<a name="401f4e9f"></a>
### XML配置


```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="..." class="...">  
        <!-- collaborators and configuration for this bean go here -->
    </bean>
    <bean id="..." class="...">
        <!-- collaborators and configuration for this bean go here -->
    </bean>
    <!-- more bean definitions go here -->
</beans>
```


<a name="1c69832d"></a>
#### 组合XML文件


```xml
<beans>
    <import resource="services.xml"/>
    <import resource="resources/messageSource.xml"/>
    <import resource="/resources/themeSource.xml"/>

    <bean id="bean1" class="..."/>
    <bean id="bean2" class="..."/>
</beans>
```


<a name="6soZU"></a>
### 注解
> @ComponentScan
> @Component
> @Service
> @Repository
> @Controller
>


<a name="P9S4y"></a>
### JavaConfig
> @Configuration
> @Import
> @Bean on method

<a name="cc07ab9f"></a>
## 实例化与使用容器
<a name="ClassPathXmlApplicationContext"></a>
### ClassPathXmlApplicationContext
```java
ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");
```
<a name="GenericApplicationContext"></a>
### GenericApplicationContext
```java
GenericApplicationContext context = new GenericApplicationContext();
new XmlBeanDefinitionReader(context).loadBeanDefinitions("services.xml", "daos.xml");
context.refresh();
```
<a name="dPuV9"></a>
### XmlWebApplicationContext
一般由Web容器初始化来初始化，常见的XML配置
```xml
<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml</param-value>
</context-param>

<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>
```
<a name="QMetI"></a>
# Bean概览
<a name="hiPDj"></a>
## 定义Bean
BeanDefinition对象主要包含如下的几部分属性

| 属性 | 描述 |
| --- | --- |
| Class | 用来实例化一个Bean |
| Name | 用来指定一个Bean的名称,用Id或Name或别名来描述 |
| Scope | 用来限定Bean的作用域 |
| Constructor Argument | 用来实现依赖注入 |
| Properties | 用来实现依赖注入 |
| Autowiring mode | 依赖注入模式,如byName |
| Lazy Initialization mode | 延迟初始化模式 |
| Initialization mode | 初始化模式 |
| Destruction mode | Bean销毁处理 |

<a name="BVaD6"></a>
### 命名Bean
> id 最常用
> name：id的别名,可指定多个,用逗号分隔
> alias：跨多个系统间调用，可以定义一个别名

示例:
```xml
<alias name="myApp-dataSource" alias="subsystemA-dataSource"/>
```
<a name="XkulI"></a>
### 实例化Bean
<a name="pIn3V"></a>
#### 通过构造方法
> 注引用一个内部类作为Bean，使用外部类加$符号，标识一个嵌套类

```xml
 <bean id="helloSpring" name="aliasForId" class="com.example.start.springdemo.spring.HelloSpring" >
        <property name="innerSpring">
            <bean class="com.example.start.springdemo.spring.HelloSpring$HelloInnerSpring"/>
        </property>
 </bean>
```
<a name="luX84"></a>
#### 通过静态工厂方法
```java
<bean id="clientService"
    class="examples.ClientService"
    factory-method="createInstance"/>

对应Class
public class ClientService {
    private static ClientService clientService = new ClientService();
    private ClientService() {}

    public static ClientService createInstance() {
        return clientService;
    }
}
```
<a name="4VEDV"></a>
#### 通过实例工厂方法
```java
<!-- the factory bean, which contains a method called createInstance() -->
<bean id="serviceLocator" class="examples.DefaultServiceLocator">
    <!-- inject any dependencies required by this locator bean -->
</bean>

<!-- the bean to be created via the factory bean -->
<bean id="clientService"
    factory-bean="serviceLocator"
    factory-method="createClientServiceInstance"/>

public class DefaultServiceLocator {

    private static ClientService clientService = new ClientServiceImpl();

    public ClientService createClientServiceInstance() {
        return clientService;
    }
}
```
工厂类可以指定多个工厂方法来创建Bean
```java
<bean id="serviceLocator" class="examples.DefaultServiceLocator">
    <!-- inject any dependencies required by this locator bean -->
</bean>

<bean id="clientService"
    factory-bean="serviceLocator"
    factory-method="createClientServiceInstance"/>

<bean id="accountService"
    factory-bean="serviceLocator"
    factory-method="createAccountServiceInstance"/>

public class DefaultServiceLocator {

    private static ClientService clientService = new ClientServiceImpl();

    private static AccountService accountService = new AccountServiceImpl();

    public ClientService createClientServiceInstance() {
        return clientService;
    }

    public AccountService createAccountServiceInstance() {
        return accountService;
    }
}    
```
<a name="NpzkE"></a>
#### 通过FactoryBean接口
> FactoryBean是Spring提供的一种扩展点，用来自定义负责的Bean初始化逻辑。通过Bean名称(如myBean)调用getBean时，返回getObject方法生成的Bean，并缓存起来。如果要获取FactoryBean本身的实例，则使用&myBean，示例如下:

```java
public class ClientServiceFactoryBean implements FactoryBean<ClientService> {

    @Override
    public ClientService getObject() throws Exception {
        return new ClientService();
    }

    @Override
    public boolean isSingleton() {
        return true;
    }

    @Override
    public Class<?> getObjectType() {
        return null;
    }
}

XML配置
<bean id="clientServiceFactoryBean" class="com.example.start.springdemo.spring.ClientServiceFactoryBean" />


使用如下:
由于是单例，client1 与client2是同一个实例
ClientService client1 = (ClientService)context.getBean("clientServiceFactoryBean");
ClientService client2 = (ClientService)context.getBean("clientServiceFactoryBean");

使用&Bean名称
ClientServiceFactoryBean fb = (ClientServiceFactoryBean)context.getBean("&clientServiceFactoryBean");
```
<a name="ijee7"></a>
# 依赖
<a name="Lc6pv"></a>
## 依赖注入
<a name="gvCDN"></a>
### 构造方法注入
<a name="6MP2r"></a>
#### 基本使用
```java
public class SimpleMovieLister {

    // the SimpleMovieLister has a dependency on a MovieFinder
    private MovieFinder movieFinder;

    // a constructor so that the Spring container can inject a MovieFinder
    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // business logic that actually uses the injected MovieFinder is omitted...
}
```
容器调用构造方法来完成注入
<a name="4OQ0g"></a>
#### 构造参数解析

<br />**构造参数很明确的场景，无模糊参数类型**
```java
package x.y;

public class ThingOne {

    public ThingOne(ThingTwo thingTwo, ThingThree thingThree) {
        // ...
    }
}
<beans>
    <bean id="beanOne" class="x.y.ThingOne">
        <constructor-arg ref="beanTwo"/>
        <constructor-arg ref="beanThree"/>
    </bean>

    <bean id="beanTwo" class="x.y.ThingTwo"/>

    <bean id="beanThree" class="x.y.ThingThree"/>
</beans>
```
**构造参数类型匹配**
```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg type="int" value="7500000"/>
    <constructor-arg type="java.lang.String" value="42"/>
</bean>
```
**指定构造参数下标索引(默认从0开始）**
```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg type="int" value="7500000"/>
    <constructor-arg type="java.lang.String" value="42"/>
</bean>
```
**指定构造参数名称**
```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg name="years" value="7500000"/>
    <constructor-arg name="ultimateAnswer" value="42"/>
</bean>
```
<a name="sZhRl"></a>
### Setter方法注入
容器调用无参构造方法或非静态方法初始化一个Bean后，再调用setter方法注入依赖
```java
public class SimpleMovieLister {

    // the SimpleMovieLister has a dependency on the MovieFinder
    private MovieFinder movieFinder;

    // a setter method so that the Spring container can inject a MovieFinder
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // business logic that actually uses the injected MovieFinder is omitted...
}
```
<a name="WYiwT"></a>
### 构造方法注入或Setter方法注入？

- 构造方法注入要求被注入的Bean必须存在，不存在则抛异常，可以做到提前检查，而不用等到运行时
- Spring 团队推荐使用构造方法注入，方便调用方法可以通过new直接构造对象，便于做单元测试等。如果有多个被注入的Bean，需求考虑是否职责不清晰，是否需要重构，分离关注点
- Setter方法注入不校验bean是否为null,需要考虑默认值



<a name="egq2s"></a>
### 循环依赖解决方案
使用构造方法注入方式产生的循环依赖，Spring IoC会抛BeanCurrentlyInCreationException，解决方案是采用Setter方法注入。
> 注Spring内部采用三级Bean缓存的机制解决循环注入，只适用与Setter方法注入场景



<a name="QpzbD"></a>
### 依赖注入示例
Case1: Setter方法
```java
<bean id="exampleBean" class="examples.ExampleBean">
    <!-- setter injection using the nested ref element -->
    <property name="beanOne">
        <ref bean="anotherExampleBean"/>
    </property>

    <!-- setter injection using the neater ref attribute -->
    <property name="beanTwo" ref="yetAnotherBean"/>
    <property name="integerProperty" value="1"/>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>

public class ExampleBean {

    private AnotherBean beanOne;

    private YetAnotherBean beanTwo;

    private int i;

    public void setBeanOne(AnotherBean beanOne) {
        this.beanOne = beanOne;
    }

    public void setBeanTwo(YetAnotherBean beanTwo) {
        this.beanTwo = beanTwo;
    }

    public void setIntegerProperty(int i) {
        this.i = i;
    }
}

```
Case2: 构造方法
```java
<bean id="exampleBean" class="examples.ExampleBean">
    <!-- constructor injection using the nested ref element -->
    <constructor-arg>
        <ref bean="anotherExampleBean"/>
    </constructor-arg>

    <!-- constructor injection using the neater ref attribute -->
    <constructor-arg ref="yetAnotherBean"/>

    <constructor-arg type="int" value="1"/>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>

public class ExampleBean {

    private AnotherBean beanOne;

    private YetAnotherBean beanTwo;

    private int i;

    public ExampleBean(
        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
        this.beanOne = anotherBean;
        this.beanTwo = yetAnotherBean;
        this.i = i;
    }
}
```
Case3: 静态工厂方法
```java
<bean id="exampleBean" class="examples.ExampleBean" factory-method="createInstance">
    <constructor-arg ref="anotherExampleBean"/>
    <constructor-arg ref="yetAnotherBean"/>
    <constructor-arg value="1"/>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>

public class ExampleBean {

    // a private constructor
    private ExampleBean(...) {
        ...
    }

    // a static factory method; the arguments to this method can be
    // considered the dependencies of the bean that is returned,
    // regardless of how those arguments are actually used.
    public static ExampleBean createInstance (
        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {

        ExampleBean eb = new ExampleBean (...);
        // some other operations...
        return eb;
    }
}
```
<a name="E4N3l"></a>
## 依赖配置详细说明
<a name="nFbu8"></a>
#### 配置Properties
```xml
    <bean id="mappings"
          class="org.springframework.context.support.PropertySourcesPlaceholderConfigurer">

        <!-- typed as a java.util.Properties -->
        <property name="properties">
            <value>
                jdbc.driver.className=com.mysql.jdbc.Driver
                jdbc.url=jdbc:mysql://localhost:3306/mydb
            </value>
        </property>
        <property name="location" value="classpath*:application.properties"/>
    </bean>
```
<a name="GJq1G"></a>
#### idref元素引用String Bean
```xml
<bean id="theTargetBean" class="..."/>

<bean id="theClientBean" class="...">
    <property name="targetName">
        <idref bean="theTargetBean"/>
    </property>
</bean>

等同于:
<bean id="theTargetBean" class="..." />

<bean id="client" class="...">
    <property name="targetName" value="theTargetBean"/>
</bean>
```
> idref 可以提前校验引用的bean是否存在，xsd4.0后不允许使用idref local标签, 可使用idref bean



<a name="z10p1"></a>
#### 引用其他Bean
```xml
<ref bean="someBean"/>

引用parent bean
<!-- in the child (descendant) context -->
<bean id="accountService" <!-- bean name is the same as the parent bean -->
    class="org.springframework.aop.framework.ProxyFactoryBean">
    <property name="target">
        <ref parent="accountService"/> <!-- notice how we refer to the parent bean -->
    </property>
    <!-- insert other configuration and dependencies as required here -->
</bean>

```
> 不推荐使用ref local -> ref bean



<a name="ED9US"></a>
#### 内部Bean
```xml
<bean id="outer" class="...">
    <!-- instead of using a reference to a target bean, simply define the target bean inline -->
    <property name="target">
        <bean class="com.example.Person"> <!-- this is the inner bean -->
            <property name="name" value="Fiona Apple"/>
            <property name="age" value="25"/>
        </bean>
    </property>
</bean>
```
> 内部Bean不需要id或name，即使指定了，Spring也不会作为注入标识符。



<a name="YWIXs"></a>
#### Collection
> The `<list/>`, `<set/>`, `<map/>`, and `<props/>` elements set the properties and arguments of the Java `Collection` types `List`, `Set`, `Map`, and `Properties`, respectively. The following example shows how to use them:



```xml
<bean id="moreComplexObject" class="example.ComplexObject">
    <!-- results in a setAdminEmails(java.util.Properties) call -->
    <property name="adminEmails">
        <props>
            <prop key="administrator">administrator@example.org</prop>
            <prop key="support">support@example.org</prop>
            <prop key="development">development@example.org</prop>
        </props>
    </property>
    <!-- results in a setSomeList(java.util.List) call -->
    <property name="someList">
        <list>
            <value>a list element followed by a reference</value>
            <ref bean="myDataSource" />
        </list>
    </property>
    <!-- results in a setSomeMap(java.util.Map) call -->
    <property name="someMap">
        <map>
            <entry key="an entry" value="just some string"/>
            <entry key ="a ref" value-ref="myDataSource"/>
        </map>
    </property>
    <!-- results in a setSomeSet(java.util.Set) call -->
    <property name="someSet">
        <set>
            <value>just some string</value>
            <ref bean="myDataSource" />
        </set>
    </property>
</bean>
```
**强类型Collection**<br />**Spring默认采用类型转换**
```java
public class SomeClass {

    private Map<String, Float> accounts;

    public void setAccounts(Map<String, Float> accounts) {
        this.accounts = accounts;
    }
}

<beans>
    <bean id="something" class="x.y.SomeClass">
        <property name="accounts">
            <map>
                <entry key="one" value="9.99"/>
                <entry key="two" value="2.75"/>
                <entry key="six" value="3.99"/>
            </map>
        </property>
    </bean>
</beans>
```
<a name="7gMna"></a>
#### Null and Empty String Value
```java
<bean class="ExampleBean">
    <property name="email" value=""/>
</bean>
==>
exampleBean.setEmail("");

处理null
<bean class="ExampleBean">
    <property name="email">
        <null/>
    </property>
</bean>
==>
exampleBean.setEmail(null);
```
<a name="8IQl8"></a>
#### XML 标签简写： p or c
> p 命名空间简写property c 命名空间简写constructor-arg


<br />

<a name="TP7DY"></a>
## 使用depends-on
明确强制让依赖的Bean先初始化
```xml
<bean id="beanOne" class="ExampleBean" depends-on="manager,accountDao">
    <property name="manager" ref="manager" />
</bean>

<bean id="manager" class="ManagerBean" />
<bean id="accountDao" class="x.y.jdbc.JdbcAccountDao" />
```
<a name="ROr3J"></a>
## Lazy初始化Bean
Spring 默认为false, 表示容器启动时即主动初始化单例Bean
> The effective default is "false".

```xml
<bean id="lazy" class="com.something.ExpensiveToCreateBean" lazy-init="true"/>
<bean name="not.lazy" class="com.something.AnotherBean"/>
```
<a name="xMSO3"></a>
## 自动注入Bean
<a name="xieWV"></a>
### 自动注入模式
| 模式 | 解释 |
| --- | --- |
| no | 默认，表示不使用自动注入，采用显示的ref描述。用以明确指定依赖结构 |
| byName | 根据Bean的名称自动注入(在容器中查找bean name) |
| byType | 根据Bean的类型自动注入(在容器中查找类型）,如果type 不存在，则抛异常 |

示例说明:
```java
定义Bean
<bean id="clientService" class="com.example.start.springdemo.spring.ClientService" factory-method="createInstance"/>

<bean id="helloSpring" name="aliasForId" class="com.example.start.springdemo.spring.HelloSpring"/>

public class HelloSpring {

    private ClientService clientService;

    /**
     * Setter method for property <tt>clientService</tt>.
     *
     * @param clientService value to be assigned to property clientService
     */
    public void setClientService(ClientService clientService) {
        this.clientService = clientService;
    }
}
```
不使用依赖注入：默认值为no<br />default-autowire="default"，内部不自动注入<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/1475094/1590634139898-498fe9f1-7688-4b79-baa0-85ae98bd1973.png#align=left&display=inline&height=190&margin=%5Bobject%20Object%5D&name=image.png&originHeight=380&originWidth=1742&size=415136&status=done&style=none&width=871)<br />default-autowire="byName", 内部自动通过Setter方法注入<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/1475094/1590634077928-488b070b-585e-4ef1-8b36-1b763c04f204.png#align=left&display=inline&height=184&margin=%5Bobject%20Object%5D&name=image.png&originHeight=368&originWidth=2054&size=489707&status=done&style=none&width=1027)<br />

<a name="suMEK"></a>
## Metho Injection(方法注入）
> 通过感知容器（耦合）显示从容器中获取Bean. 实现ApplicationContextAware接口，调用getBean

```java
// a class that uses a stateful Command-style class to perform some processing
package fiona.apple;

// Spring-API imports
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

public class CommandManager implements ApplicationContextAware {

    private ApplicationContext applicationContext;

    public Object process(Map commandState) {
        // grab a new instance of the appropriate Command
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    protected Command createCommand() {
        // notice the Spring API dependency!
        return this.applicationContext.getBean("command", Command.class);
    }

    public void setApplicationContext(
            ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
}
```


<a name="FHCaC"></a>
# Bean作用域
| Scope（作用域) | 描述 |
| --- | --- |
| singleton（单例） | 默认，Spring只会创建一个Bean实例 |
| prototype (原型） | 创建多个Bean实例 |
| request (请求) | Web应用，对应Http Request |
| session (会话) | Web应用，对应Http Session |
| applicaiton (应用) | Web应用，对应Servlet Context |
| websocket | Websocket |

<a name="A1bAZ"></a>
### 单例作用域
定义方式
```xml
<bean id="accountService" class="com.something.DefaultAccountService"/>

<!-- the following is equivalent, though redundant (singleton scope is the default) -->
<bean id="accountService" class="com.something.DefaultAccountService" scope="singleton"/>
```
![image.png](https://cdn.nlark.com/yuque/0/2020/png/1475094/1590635819229-0ecad971-4cca-47af-8446-d3b020b20f03.png#align=left&display=inline&height=410&margin=%5Bobject%20Object%5D&name=image.png&originHeight=820&originWidth=1644&size=613954&status=done&style=none&width=822)
<a name="KZjLN"></a>
### 原型作用域
通常来说，原型作用域用于有状态的bean, 被注入到不同的bean里，会新产生一个实例。
> 关键点: 容器调用getBean返回一个新的实例


<br />定义方式如下:
```xml
<bean id="accountService" class="com.something.DefaultAccountService" scope="prototype"/>
```
![image.png](https://cdn.nlark.com/yuque/0/2020/png/1475094/1590636060343-c920d0dd-1a1b-4ee0-ab97-f33eeb8b26b5.png#align=left&display=inline&height=386&margin=%5Bobject%20Object%5D&name=image.png&originHeight=772&originWidth=1642&size=582948&status=done&style=none&width=821)
> 注入不同的Dao实例



<a name="asV4j"></a>
# 自定义Bean的性质(Nature of Bean)
<a name="MDdSz"></a>
### 生命周期回调（Lifecycle Callback)
> Spring API 提供的InitializingBean与DisposableBean，分别提供afterPropertiesSet()与destroy()方法来定义初始化或清理Bean的特殊行为
> 如果不想耦合Spring内部的接口，可以使用JSR-250 定义的注解@PostConstruct @PreDestroy
> 如果不想使用@PostConstruct @PreDestroy，又不想与Spring耦合，可以使用init-method, destroy-method



**Spring内部都是采用BeanPostProcessor机制来处理Bean 生命周期回调**

<a name="nho06"></a>
#### Initialization Callback
1) 使用InitializingBean, Spring 不推荐使用，因为没有必要耦合Spring，推荐使用@PostConstruct<br />2) 如果是xml配置，可采用init-method(无参数)<br />3) 如果是Java Config, 可采用@Bean#initMethod<br />

<a name="U4mpR"></a>
#### Destruction Callback
1) 使用DisposableBean<br />2) 使用destroy-method 或@Bean#destroyMethod<br />3) 使用@PreDestroy<br />

<a name="xFhUA"></a>
#### 多种方法的处理流程
> Multiple lifecycle mechanisms configured for the same bean, with different initialization methods, are called as follows:
> 1. Methods annotated with `@PostConstruct`<br />
> 1. `afterPropertiesSet()` as defined by the `InitializingBean` callback interface<br />
> 1. A custom configured `init()` method<br />
>
Destroy methods are called in the same order:
> 1. Methods annotated with `@PreDestroy`<br />
> 1. `destroy()` as defined by the `DisposableBean` callback interface<br />
> 1. A custom configured `destroy()` method<br />



<a name="SDCeF"></a>
### 容器启动或关闭回调
> 使用LifecycleProcessor

<a name="1C5Es"></a>
### IoC容器优雅关闭
```java
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public final class Boot {

    public static void main(final String[] args) throws Exception {
        ConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");

        // add a shutdown hook for the above context...
        ctx.registerShutdownHook();

        // app runs here...

        // main method exits, hook is called prior to the app shutting down...
    }
}
```
<a name="cOuan"></a>
## 感知容器（Aware)
> 常用的接口: ApplicationContextAware and BeanNameAware
> 额外可能需要关注: ApplicationEventPublisherAware



<a name="7tfpe"></a>
# Bean继承
```xml
<bean id="inheritedTestBean" abstract="true"
        class="org.springframework.beans.TestBean">
    <property name="name" value="parent"/>
    <property name="age" value="1"/>
</bean>

<bean id="inheritsWithDifferentClass"
        class="org.springframework.beans.DerivedTestBean"
        parent="inheritedTestBean" init-method="initialize">  
    <property name="name" value="override"/>
    <!-- the age property value of 1 will be inherited from parent -->
</bean>

不需要实例化Parent Bean
<bean id="inheritedTestBeanWithoutClass" abstract="true">
    <property name="name" value="parent"/>
    <property name="age" value="1"/>
</bean>

<bean id="inheritsWithClass" class="org.springframework.beans.DerivedTestBean"
        parent="inheritedTestBeanWithoutClass" init-method="initialize">
    <property name="name" value="override"/>
    <!-- age will inherit the value of 1 from the parent bean definition-->
</bean>
```
<a name="u8UfU"></a>
# 自定义扩展点
<a name="8pKqd"></a>
## 使用BeanPostProcessor
> A bean post-processor typically checks for callback interfaces, or it may wrap a bean with a proxy. Some Spring AOP infrastructure classes are implemented as bean post-processors in order to provide proxy-wrapping logic.
> spring 会针对post-processor bean在容器启动时初始化，作特殊处理。bean post-prosessor 作用域容器里的bean, 在bean作初始化阶段之前(init-method,initializingbean,postconstruct)或初始化之后。



<a name="klumZ"></a>
### HelloWorldBeanPostProcessor
```java
public class HelloWorldBeanPostProcessor implements BeanPostProcessor {

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("before init. beanName:" + beanName + ", bean:" + bean);
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("Bean '" + beanName + "' created : " + bean.toString());
        return bean;
    }
}
<bean class="com.example.start.springdemo.spring.HelloWorldBeanPostProcessor"/>
```
处理日志:
```
before init. beanName:helloSpring, bean:com.example.start.springdemo.spring.HelloSpring@36a5cabc
###########HelloSpringBean Init##########
Bean 'helloSpring' created : com.example.start.springdemo.spring.HelloSpring@36a5cabc
```


<a name="BX4Wg"></a>
## BeanFactoryPostProcessor(配置Bean定义元数据)
> Spring includes a number of predefined bean factory post-processors, such as PropertyOverrideConfigurer and PropertySourcesPlaceholderConfigurer. You can also use a custom BeanFactoryPostProcessor — for example, to register custom property editors.

<a name="sPAH7"></a>
###
<a name="yJbiy"></a>
### 类名或属性替换PropertySourcesPlaceholderConfigurer
```xml
<bean class="org.springframework.context.support.PropertySourcesPlaceholderConfigurer">
    <property name="locations" value="classpath:com/something/jdbc.properties"/>
</bean>

<bean id="dataSource" destroy-method="close"
        class="org.apache.commons.dbcp.BasicDataSource">
    <property name="driverClassName" value="${jdbc.driverClassName}"/>
    <property name="url" value="${jdbc.url}"/>
    <property name="username" value="${jdbc.username}"/>
    <property name="password" value="${jdbc.password}"/>
</bean>
```
还可采用context标签用法:
> <context:property-placeholder location="classpath:com/something/jdbc.properties"/>
> 多个文件用逗号分隔


<br />选择一个运行时具体的类：
```xml
<bean class="org.springframework.beans.factory.config.PropertySourcesPlaceholderConfigurer">
    <property name="locations">
        <value>classpath:com/something/strategy.properties</value>
    </property>
    <property name="properties">
        <value>custom.strategy.class=com.something.DefaultStrategy</value>
    </property>
</bean>

<bean id="serviceStrategy" class="${custom.strategy.class}"/>
```
<a name="k7C5y"></a>
### 属性覆盖PropertyOverrideConfigurer


<a name="BLSut"></a>
## 自定义初始化逻辑FactoryBean
> see org.springframework.beans.factory.FactoryBean



<a name="OITR1"></a>
# 基于注解的容器配置
> 注解配置还是XML配置好？要看情况。注解表达更简洁，XML擅长组织Bean装配(wiring)或不用重新编译源代码。



<a name="YL7mb"></a>
## 启用注解
> <context:annotation-config/>
> (上述标签会隐式注册几个post-processor.
> (The implicitly registered post-processors include AutowiredAnnotationBeanPostProcessor, CommonAnnotationBeanPostProcessor, PersistenceAnnotationBeanPostProcessor, and the aforementioned RequiredAnnotationBeanPostProcessor.)
> 注: context:annotaion-config只会在相同的application context里查找Bean



<a name="rsWIE"></a>
## 使用@Required
表示必须存在的Bean, 注: Spring 5.1以后已废弃该注解.使用构造注入<br />

<a name="ajWSZ"></a>
## 使用@Autowired
> 指定required=false,表示不强校验bean 是否存在

<a name="7S61q"></a>
### 构造方法注入
```java
public class MovieRecommender {

    private final CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}

```
<a name="wIvs1"></a>
### Setter注入
```java
public class MovieRecommender {

    private final CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}

```
<a name="y37s0"></a>
### 任意方法注入
```java
public class MovieRecommender {

    private MovieCatalog movieCatalog;

    private CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public void prepare(MovieCatalog movieCatalog,
            CustomerPreferenceDao customerPreferenceDao) {
        this.movieCatalog = movieCatalog;
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}
```
<a name="FTBE8"></a>
### 注入字段或混合使用
```java
public class MovieRecommender {

    private final CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    private MovieCatalog movieCatalog;

    @Autowired
    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}
```
<a name="dWjtz"></a>
### 注入集合或数组或Map
```java
    @Autowired
    private MovieCatalog[] movieCatalogs;

	@Autowired
    private List<MovieCatalog> movieCatalogs;

    private Set<MovieCatalog> movieCatalogs;

    @Autowired
    public void setMovieCatalogs(Set<MovieCatalog> movieCatalogs) {
        this.movieCatalogs = movieCatalogs;
    }

	// key is beanName
    private Map<String, MovieCatalog> movieCatalogs;

    @Autowired
    public void setMovieCatalogs(Map<String, MovieCatalog> movieCatalogs) {
        this.movieCatalogs = movieCatalogs;
    }

```
<a name="Vdyie"></a>
### 注入ApplicationContext,BeanFactory等
> You can also use @Autowired for interfaces that are well-known resolvable dependencies: BeanFactory, ApplicationContext, Environment, ResourceLoader, ApplicationEventPublisher, and MessageSource

```java
    @Autowired
    private ApplicationContext context;

```


<a name="FtYZO"></a>
## Tune with @Primary or @Qualifier
> **@Autowired @Primary**

<a name="2iASI"></a>
## 泛型注入
```java
@Autowired
private Store<String> s1; // <String> qualifier, injects the stringStore bean

@Autowired
private Store<Integer> s2; // <Integer> qualifier, injects the integerStore bean
```
<a name="27EEm"></a>
## 使用@Resource注入
> Resource为JSF-250提供的，用于注入字段，setter方法, 可用name指定具体的bean。若未指定name, 默认取字段名称或Setter方法的属性名称。see CommonAnnotationBeanPostProcessor.
>

> 先基于name查找，再根据type查找

```java
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Resource(name="myMovieFinder")
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}
```
<a name="ohLQq"></a>
## 使用@Value
> 主要用来注入外部属性

```java
@Configuration
@PropertySource("classpath:application.properties")
public class AppConfig { }

@Component
public class MovieRecommender {

    private final String catalog;

    public MovieRecommender(@Value("${catalog.name:defaultValue}") String catalog) {
        this.catalog = catalog;
    }
}

application.properties
catalog.name=MovieCatalog
```
如果占位符字段不存在，可以使用默认值。
> 特殊场景，可自定义ConversionService

<a name="NTlhY"></a>
## 使用@PostConstrct and @PreDestroy
> 原理见 CommonAnnotationBeanPostProcessor

```java
public class CachingMovieLister {

    @PostConstruct
    public void populateMovieCache() {
        // populates the movie cache upon initialization...
    }

    @PreDestroy
    public void clearMovieCache() {
        // clears the movie cache upon destruction...
    }
}
```
<a name="n4QCc"></a>
# 类路径扫描并管理Component
> @Component @Service @Repository @Controller
>



<a name="on5Eh"></a>
## 自动扫描
> <context:component-scan base-package="org.example"/>
> The use of <context:component-scan> implicitly enables the functionality of <context:annotation-config>. There is usually no need to include the <context:annotation-config> element when using <context:component-scan>.

```java
@Configuration
@ComponentScan(basePackages = "org.example")
public class AppConfig  {
    // ...
}
```
> 自动扫描机制由如下两个processor实现: AutowiredAnnotationBeanPostProcessor and CommonAnnotationBeanPostProcessor


<br />配置扫描策略:
```java
JavaConfig
@Configuration
@ComponentScan(basePackages = "org.example",
        includeFilters = @Filter(type = FilterType.REGEX, pattern = ".*Stub.*Repository"),
        excludeFilters = @Filter(Repository.class))
public class AppConfig {
    ...
}

XML方式
<beans>
    <context:component-scan base-package="org.example">
        <context:include-filter type="regex"
                expression=".*Stub.*Repository"/>
        <context:exclude-filter type="annotation"
                expression="org.springframework.stereotype.Repository"/>
    </context:component-scan>
</beans>
```
<a name="uoE9A"></a>
## 命名Component
```java
@Service("myMovieLister")
public class SimpleMovieLister {
    // ...
}
```
> 如果没有指定名称，默认使用BeanNameGenerator来生成bean name.默认为小写首字母的类全称



<a name="MHwX2"></a>
# 使用JSR330标准注解
<a name="H3tAk"></a>
## @Inject and @Named
```java
import javax.inject.Inject;

public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(@Named("main") MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}
```
<a name="YZKNr"></a>
# Java Config 注解配置Bean
<a name="TcpeI"></a>
## 基本概览
> @Bean like <bean> @Confirguration like <beans>

```java
@Configuration
public class AppConfig {

    @Bean
    public MyService myService() {
        return new MyServiceImpl();
    }
}
```
<a name="fDbr8"></a>
## 注解配置容器AnnotationConfigApplicationContext
> ClassPathXmlApplicationContext 也能兼容@Configuration @Bean注解
> AnnotationConfigApplicationContext能处理所有的注解,如Component,JSR-330注解

```java
public static void main(String[] args) {
ApplicationContext ctx =
            new AnnotationConfigApplicationContext("com.example.start.springdemo.spring");

        System.out.println(Arrays.toString(ctx.getBeanDefinitionNames()));
}
```
<a name="OYtIa"></a>
### registerClass(?)
```java
public static void main(String[] args) {
    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
    ctx.register(AppConfig.class, OtherConfig.class);
    ctx.register(AdditionalConfig.class);
    ctx.refresh();
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}
```
<a name="2gkhL"></a>
### 注解扫描
```java
@Configuration
@ComponentScan(basePackages = "com.acme")
public class AppConfig  {
    ...
}
```
<a name="1wBIV"></a>
### Config+Autowired
```java
@Configuration
public class ServiceConfig {

    @Autowired
    private AccountRepository accountRepository;

    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl(accountRepository);
    }
}

@Configuration
public class RepositoryConfig {

    private final DataSource dataSource;

    public RepositoryConfig(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    @Bean
    public AccountRepository accountRepository() {
        return new JdbcAccountRepository(dataSource);
    }
}

@Configuration
@Import({ServiceConfig.class, RepositoryConfig.class})
public class SystemTestConfig {

    @Bean
    public DataSource dataSource() {
        // return new DataSource
    }
}

public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
    // everything wires up across configuration classes...
    TransferService transferService = ctx.getBean(TransferService.class);
    transferService.transfer(100.00, "A123", "C456");
}
```
<a name="2I6QQ"></a>
### JavaConfig+XML配置
```java
@Configuration
public class AppConfig {

    @Autowired
    private DataSource dataSource;

    @Bean
    public AccountRepository accountRepository() {
        return new JdbcAccountRepository(dataSource);
    }

    @Bean
    public TransferService transferService() {
        return new TransferService(accountRepository());
    }
}

system-test-config.xml

<beans>
    <!-- enable processing of annotations such as @Autowired and @Configuration -->
    <context:annotation-config/>
    <context:property-placeholder location="classpath:/com/acme/jdbc.properties"/>

    <bean class="com.acme.AppConfig"/>

    <bean class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>
</beans>

public static void main(String[] args) {
    ApplicationContext ctx = new ClassPathXmlApplicationContext("classpath:/com/acme/system-test-config.xml");
    TransferService transferService = ctx.getBean(TransferService.class);
    // ...
}
```
 In system-test-config.xml file, the AppConfig <bean/> does not declare an id element. While it would be acceptable to do so, it is unnecessary, given that no other bean ever refers to it, and it is unlikely to be explicitly fetched from the container by name. Similarly, the DataSource bean is only ever autowired by type, so an explicit bean id is not strictly required.

<br />**Using <context:component-scan/> to pick up @Configuration classes**
```xml
<beans>
    <!-- picks up and registers AppConfig as a bean definition -->
    <context:component-scan base-package="com.acme"/>
    <context:property-placeholder location="classpath:/com/acme/jdbc.properties"/>

    <bean class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>
</beans>
```
**@Configuration Class-centric Use of XML with @ImportResource**
```java
@Configuration
@ImportResource("classpath:/com/acme/properties-config.xml")
public class AppConfig {

    @Value("${jdbc.url}")
    private String url;

    @Value("${jdbc.username}")
    private String username;

    @Value("${jdbc.password}")
    private String password;

    @Bean
    public DataSource dataSource() {
        return new DriverManagerDataSource(url, username, password);
    }
}

properties-config.xml
<beans>
    <context:property-placeholder location="classpath:/com/acme/jdbc.properties"/>
</beans>


main
public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
    TransferService transferService = ctx.getBean(TransferService.class);
    // ...
}
```
<a name="k2cXZ"></a>
# 环境抽象


<a name="b749Z"></a>
# 注册LoadTimeWeaver


<a name="ruXcd"></a>
# ApplicationContext附加能力
<a name="cebcj"></a>
## 国际化MessageSource
> 优先使用
> org.springframework.context.support.ReloadableResourceBundleMessageSource

```xml
<beans>

    <!-- this MessageSource is being used in a web application -->
    <bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource">
        <property name="basename" value="exceptions"/>
    </bean>

    <!-- lets inject the above MessageSource into this POJO -->
    <bean id="example" class="com.something.Example">
        <property name="messages" ref="messageSource"/>
    </bean>

</beans>

使用
public class Example {

    private MessageSource messages;

    public void setMessages(MessageSource messages) {
        this.messages = messages;
    }

    public void execute() {
        String message = this.messages.getMessage("argument.required",
            new Object [] {"userDao"}, "Required", Locale.ENGLISH);
        System.out.println(message);
    }
}
```


<a name="3BAoe"></a>
## 容器事件
```java
public class EmailService implements ApplicationEventPublisherAware {

    private List<String> blackList;
    private ApplicationEventPublisher publisher;

    public void setBlackList(List<String> blackList) {
        this.blackList = blackList;
    }

    public void setApplicationEventPublisher(ApplicationEventPublisher publisher) {
        this.publisher = publisher;
    }

    public void sendEmail(String address, String content) {
        if (blackList.contains(address)) {
            publisher.publishEvent(new BlackListEvent(this, address, content));
            return;
        }
        // send email...
    }
}
```
<a name="2jUca"></a>
# BeanFactory
> `GenericApplicationContext` and its subclass `AnnotationConfigApplicationContext` as the common implementations for custom bootstrapping. These are the primary entry points to Spring’s core container for all common purposes: loading of configuration files, triggering a classpath scan, programmatically registering bean definitions and annotated classes, and (as of 5.0) registering functional bean definitions.



```java
DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
// populate the factory with bean definitions

// now register any needed BeanPostProcessor instances
factory.addBeanPostProcessor(new AutowiredAnnotationBeanPostProcessor());
factory.addBeanPostProcessor(new MyBeanPostProcessor());

// now start using the factory

```
BeanFactory使用PostProcess
```java
DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);
reader.loadBeanDefinitions(new FileSystemResource("beans.xml"));

// bring in some property values from a Properties file
PropertySourcesPlaceholderConfigurer cfg = new PropertySourcesPlaceholderConfigurer();
cfg.setLocation(new FileSystemResource("jdbc.properties"));

// now actually do the replacement
cfg.postProcessBeanFactory(factory);
```
