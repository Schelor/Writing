# 重构
> 重构过程包括：去重重复的代码，澄清模糊的代码，简化复杂的逻辑
1. 使新代码的增加更容易
2. 改善既有代码的设计
3. 对代码理解更透彻
4. 提高编程的趣味性
5. 可读性好的代码
6. 保持清晰的代码
7. 循序渐进的重构

## 代码坏味道
| Bad Smell | Refactor     |
| :------------- | :------------- |
| 重复代码       |  模板方法, 用工厂模式引入多态创建, 组合小方法块,  适配器模式, 引入Null对象      |
| 方法过长       |    组合方法, 用多个方法Collection Paramers， 用Command替换条件调度， 用Strategy，       |
| 条件逻辑太复杂        |  使用Strategy, 使用装饰器， 使用State        |
| 基本类型迷恋        |          |
| 不恰当的暴露       |          |
| 解决方案蔓延       |          |
| 异曲同工的类       |          |
| 冗赘类       |          |
| 类过大       |          |
| 分支语句       |          |
| 组合爆炸       |          |
| 怪异解决方案(不一致方法)       |       ..    |

# 重构与模式
## Creation(创建对象)
### Creation Method
用Creation Method 替换构造函数(与Effective Java的静态工厂方法思想一致)
具体还可：引入参数化，提取Factory

### 将Creation Knowledge 搬移到Factory
Factory的定义：实现一个或多个Creation Method的类就称为Factory: Creation Method可以是静态的，非静态的，返回类型可以是接口，抽象类，具体类，类的职责也可引入非创建职责。

### 用Factory(静态工厂方法)封装类的创建
把类的构造方法声明为protected，并通过Factory方法来创建他们的实例，可返还子类化的实例
变体：封装内部类，参见java.util.Collections中的静态方法

### 用Factory Method引入堕胎创建
模板类定义抽象创建方法，返回类型为接口或父类，由具体的子类实现模板方法，创建多态对象

### 使用Builder来封装复合(组合)对象的创建过程

### 适当的时候内联化单例类

## 简化代码
### 用表意明确的方法名称来组合其他方法
需要把方法分解成命名良好，且各个方法的细节需要在同一层面
比如上班包括：起床，洗漱，穿戴，出门，而洗脸，刷牙在洗漱这一逻辑层下，穿T恤和休闲裤则在穿戴这一个逻辑层下。组合方法的一些原则：
1. 方法块不超过10行，最好5行左右
2. 删除重复代码，死代码
3. 表达清晰的意图，清楚的命名变量，参数
4. 简化，简洁
5. 使用细节的同一层面


### 用Strategy替换条件逻辑
把一些条件逻辑或算法逻辑封装到一个策略中，作为可替换的策略方案。同时简化主类的代码

### 将装饰功能搬移到Decorator
装饰类为目标类增加装饰功能，丰富功能，简化类，有效的把类的核心职责与装饰功能区分开，同时需要与目标类的接口或抽象一致。

### 用State替换状态改变条件语句
简化复杂的状态改变逻辑

### 用Command替换条件调度逻辑
为每个处理动作(逻辑)创建一个Command，把这些Command存在一个集合中，并在调用端，获取Command，并执行Command.
需要提到的是，如果条件逻辑代码量很少，则不需要使用Command, 增加复杂性，需要权衡需求。
```
Handler handler = lookup(handleName)
handler.execute(Parameter)

```

## 泛化，编写更通用的代码
### 模板方法
把不变的行为搬到基类中，去重子类中的重复代码，子类还可以重新一些抽象方法，增加多样性。

### 通过Adapter统一接口
适配器模式是两个不兼容接口之间的桥梁。这种类型的设计模式来自于结构模式，结构模式将两个互相独立的接口组合起来。
场景：
1. 两个类所做的事情相同或相似，但是具有不同的接口
2. 如果类共享同一个接口，客户代码会更简单，更直接，更紧凑
3. 无法轻易改变其中一个类的接口(三方库,被客户广泛使用)


## 随笔记录
### 门面模式
1. 服务外观
Facade {
  @Inject
  AService a;
  BService b;

  void s() {
    a.a()
    b.b()
  }
}
2. 方法外观
Facade {
  void a() {
    first()
    second()
    third()
  }
}

### 依赖注入
依赖反转原则：
1. 高层模块不应该依赖于底层模块，他们都应该依赖于抽象
2. 抽象不应该依赖于细节，细节应该依赖于抽象
### 实践&阅读
https://github.com/JetBrains/intellij-community
http://www.importnew.com/14260.html
